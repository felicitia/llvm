diff -ruN ./clang/include/clang/AST/StmtOpenMP.h ../llvm-project/clang/include/clang/AST/StmtOpenMP.h
--- ./clang/include/clang/AST/StmtOpenMP.h	2023-03-13 16:17:24.456363948 -0400
+++ ../llvm-project/clang/include/clang/AST/StmtOpenMP.h	2023-03-13 11:41:59.191929121 -0400
@@ -613,13 +613,13 @@
   ///
   OMPNmrDirective(SourceLocation StartLoc, SourceLocation EndLoc)
       : OMPExecutableDirective(OMPNmrDirectiveClass,
-                               llvm::omp::OMPD_parallel, StartLoc, EndLoc) {}
+                               llvm::omp::OMPD_nmr, StartLoc, EndLoc) {}
 
   /// Build an empty directive.
   ///
   explicit OMPNmrDirective()
       : OMPExecutableDirective(OMPNmrDirectiveClass,
-                               llvm::omp::OMPD_parallel, SourceLocation(),
+                               llvm::omp::OMPD_nmr, SourceLocation(),
                                SourceLocation()) {}
 
   /// Sets special task reduction descriptor.
@@ -2901,13 +2901,13 @@
   /// \param EndLoc Ending location of the directive.
   ///
   OMPVoteDirective(SourceLocation StartLoc, SourceLocation EndLoc)
-      : OMPExecutableDirective(OMPVoteDirectiveClass, llvm::omp::OMPD_dkflush,
+      : OMPExecutableDirective(OMPVoteDirectiveClass, llvm::omp::OMPD_vote,
                                StartLoc, EndLoc) {}
 
   /// Build an empty directive.
   ///
   explicit OMPVoteDirective()
-      : OMPExecutableDirective(OMPVoteDirectiveClass, llvm::omp::OMPD_dkflush,
+      : OMPExecutableDirective(OMPVoteDirectiveClass, llvm::omp::OMPD_vote,
                                SourceLocation(), SourceLocation()) {}
 
 public:
diff -ruN ./clang/include/clang/Parse/Parser.h ../llvm-project/clang/include/clang/Parse/Parser.h
--- ./clang/include/clang/Parse/Parser.h	2023-03-13 16:17:24.560364413 -0400
+++ ../llvm-project/clang/include/clang/Parse/Parser.h	2023-03-13 10:00:41.272499445 -0400
@@ -3323,6 +3323,8 @@
   // ifdef DK
   OMPClause *ParseOpenMPDoubleVarListClause(OpenMPDirectiveKind DKind,
                                       OpenMPClauseKind Kind, bool ParseOnly);
+  OMPClause *ParseFTDoubleVarListClause(OpenMPDirectiveKind DKind,
+                                      OpenMPClauseKind Kind, bool ParseOnly);
   // endif
   
   /// Parses and creates OpenMP 5.0 iterators expression:
diff -ruN ./clang/include/clang/Sema/Sema.h ../llvm-project/clang/include/clang/Sema/Sema.h
--- ./clang/include/clang/Sema/Sema.h	2023-03-13 16:17:24.572364468 -0400
+++ ../llvm-project/clang/include/clang/Sema/Sema.h	2023-03-10 09:05:29.369165830 -0500
@@ -10792,6 +10792,10 @@
       OpenMPDirectiveKind CancelRegion, ArrayRef<OMPClause *> Clauses,
       Stmt *AStmt, SourceLocation StartLoc, SourceLocation EndLoc);
   // ifdef DK
+  StmtResult ActOnFTExecutableDirective(
+      OpenMPDirectiveKind Kind, const DeclarationNameInfo &DirName,
+      ArrayRef<OMPClause *> Clauses,
+      Stmt *AStmt, SourceLocation StartLoc, SourceLocation EndLoc);
   StmtResult ActOnOpenMPFTDirective(ArrayRef<OMPClause *> Clauses,
                                           Stmt *AStmt,
                                           SourceLocation StartLoc,
diff -ruN ./clang/lib/Basic/OpenMPKinds.cpp ../llvm-project/clang/lib/Basic/OpenMPKinds.cpp
--- ./clang/lib/Basic/OpenMPKinds.cpp	2023-03-13 16:17:24.712365093 -0400
+++ ../llvm-project/clang/lib/Basic/OpenMPKinds.cpp	2023-03-13 14:23:57.990611246 -0400
@@ -654,7 +654,7 @@
   case OMPD_metadirective:
     CaptureRegions.push_back(OMPD_metadirective);
     break;
-  case OMPD_vote:
+//  case OMPD_vote:
   case OMPD_nmr:
   case OMPD_parallel:
   case OMPD_parallel_for:
diff -ruN ./clang/lib/CodeGen/CGStmtOpenMP.cpp ../llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp
--- ./clang/lib/CodeGen/CGStmtOpenMP.cpp	2023-03-13 16:17:24.792365452 -0400
+++ ../llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp	2023-03-09 18:33:58.128921331 -0500
@@ -1578,18 +1578,6 @@
        TSize = CGF.EmitScalarExpr(VarsSizes[i+1], /*IgnoreResultAssign=*/true);
      }
      CGF.CGM.getOpenMPRuntime().emitFTVoteClause(CGF, Varaddr, TSize, Loc);
-#if 0
-     bool generate_code_before = false;
-     bool generate_code_after = false;
-     if (S == nullptr) 
-         CGF.CGM.getOpenMPRuntime().emitFTVoteClause(CGF, Varaddr, TSize, Loc);
-     else {
-       if (generate_code_after == true) CGF.EmitStmt(S);
-       CGF.CGM.getOpenMPRuntime().emitFTVoteClause(CGF, Varaddr, TSize, S->getBeginLoc());
-       if (generate_code_before == true) CGF.EmitStmt(S);
-       if (generate_code_before == false && generate_code_after == false) CGF.EmitStmt(S);
-    }
-#endif
   }
 }
 
@@ -1600,8 +1588,8 @@
     if (RVarsNameIndex.size() > 0) {
       SmallVector<const Expr *, 4> TVarsSizes;
       for (int i=0; i < (int)RVarsNameIndex.size(); i++) {
-        TVarsSizes.push_back(RVarsSizes[i*2]);
-        TVarsSizes.push_back(RVarsSizes[i*2+1]);
+        TVarsSizes.push_back(RVarsSizes[RVarsNameIndex[i]]);
+        TVarsSizes.push_back(RVarsSizes[RVarsNameIndex[i]+1]);
       }
       emitVoteStmt(CGF, TVarsSizes, S->getBeginLoc());
     }
@@ -1609,8 +1597,8 @@
     if (LVarsNameIndex.size() > 0) {
       SmallVector<const Expr *, 4> TVarsSizes;
       for (int i=0 ; i < (int)LVarsNameIndex.size(); i++) {
-        TVarsSizes.push_back(LVarsSizes[i*2]);
-        TVarsSizes.push_back(LVarsSizes[i*2+1]);
+        TVarsSizes.push_back(LVarsSizes[RVarsNameIndex[i]]);
+        TVarsSizes.push_back(LVarsSizes[RVarsNameIndex[i]+1]);
       }
       emitVoteStmt(CGF, TVarsSizes, S->getBeginLoc());
     }
diff -ruN ./clang/lib/Parse/ParseOpenMP.cpp ../llvm-project/clang/lib/Parse/ParseOpenMP.cpp
--- ./clang/lib/Parse/ParseOpenMP.cpp	2023-03-13 16:17:25.016366454 -0400
+++ ../llvm-project/clang/lib/Parse/ParseOpenMP.cpp	2023-03-13 15:54:57.318097721 -0400
@@ -2011,9 +2011,9 @@
       Toks.push_back(Tok);
       while (Cnt && Tok.isNot(tok::eof)) {
         (void)ConsumeAnyToken();
-        if (Tok.isOneOf(tok::annot_pragma_openmp, tok::annot_attr_openmp))
+        if (Tok.isOneOf(tok::annot_pragma_ft, tok::annot_attr_ft))
           ++Cnt;
-        else if (Tok.is(tok::annot_pragma_openmp_end))
+        else if (Tok.is(tok::annot_pragma_ft_end))
           --Cnt;
         Toks.push_back(Tok);
       }
@@ -2055,23 +2055,23 @@
     if (!ParseOpenMPSimpleVarList(DKind, Helper,
                                   /*AllowScopeSpecifier=*/true)) {
       SmallVector<OMPClause *, 1> Clauses;
-      if (Tok.isNot(tok::annot_pragma_openmp_end)) {
+      if (Tok.isNot(tok::annot_pragma_ft_end)) {
         SmallVector<llvm::PointerIntPair<OMPClause *, 1, bool>,
                     llvm::omp::Clause_enumSize + 1>
             FirstClauses(llvm::omp::Clause_enumSize + 1);
-        while (Tok.isNot(tok::annot_pragma_openmp_end)) {
+        while (Tok.isNot(tok::annot_pragma_ft_end)) {
           OpenMPClauseKind CKind =
               Tok.isAnnotation() ? OMPC_unknown
                                  : getOpenMPClauseKind(PP.getSpelling(Tok));
           Actions.StartOpenMPClause(CKind);
           OMPClause *Clause = ParseOpenMPClause(
               OMPD_allocate, CKind, !FirstClauses[unsigned(CKind)].getInt());
-          SkipUntil(tok::comma, tok::identifier, tok::annot_pragma_openmp_end,
+          SkipUntil(tok::comma, tok::identifier, tok::annot_pragma_ft_end,
                     StopBeforeMatch);
           FirstClauses[unsigned(CKind)].setInt(true);
           if (Clause != nullptr)
             Clauses.push_back(Clause);
-          if (Tok.is(tok::annot_pragma_openmp_end)) {
+          if (Tok.is(tok::annot_pragma_ft_end)) {
             Actions.EndOpenMPClause();
             break;
           }
@@ -2095,24 +2095,24 @@
     SmallVector<llvm::PointerIntPair<OMPClause *, 1, bool>,
                 llvm::omp::Clause_enumSize + 1>
         FirstClauses(llvm::omp::Clause_enumSize + 1);
-    if (Tok.is(tok::annot_pragma_openmp_end)) {
+    if (Tok.is(tok::annot_pragma_ft_end)) {
       Diag(Tok, diag::err_omp_expected_clause)
           << getOpenMPDirectiveName(OMPD_requires);
       break;
     }
-    while (Tok.isNot(tok::annot_pragma_openmp_end)) {
+    while (Tok.isNot(tok::annot_pragma_ft_end)) {
       OpenMPClauseKind CKind = Tok.isAnnotation()
                                    ? OMPC_unknown
                                    : getOpenMPClauseKind(PP.getSpelling(Tok));
       Actions.StartOpenMPClause(CKind);
       OMPClause *Clause = ParseOpenMPClause(
           OMPD_requires, CKind, !FirstClauses[unsigned(CKind)].getInt());
-      SkipUntil(tok::comma, tok::identifier, tok::annot_pragma_openmp_end,
+      SkipUntil(tok::comma, tok::identifier, tok::annot_pragma_ft_end,
                 StopBeforeMatch);
       FirstClauses[unsigned(CKind)].setInt(true);
       if (Clause != nullptr)
         Clauses.push_back(Clause);
-      if (Tok.is(tok::annot_pragma_openmp_end)) {
+      if (Tok.is(tok::annot_pragma_ft_end)) {
         Actions.EndOpenMPClause();
         break;
       }
@@ -2167,7 +2167,7 @@
     ASTContext &ASTCtx = Actions.getASTContext();
     OMPTraitInfo &TI = ASTCtx.getNewOMPTraitInfo();
     if (parseOMPDeclareVariantMatchClause(Loc, TI, ParentTI)) {
-      while (!SkipUntil(tok::annot_pragma_openmp_end, Parser::StopBeforeMatch))
+      while (!SkipUntil(tok::annot_pragma_ft_end, Parser::StopBeforeMatch))
         ;
       // Skip the last annot_pragma_openmp_end.
       (void)ConsumeAnnotationToken();
@@ -2237,7 +2237,7 @@
     CachedTokens Toks;
     Toks.push_back(Tok);
     ConsumeToken();
-    while (Tok.isNot(tok::annot_pragma_openmp_end)) {
+    while (Tok.isNot(tok::annot_pragma_ft_end)) {
       Toks.push_back(Tok);
       ConsumeAnyToken();
     }
@@ -2245,7 +2245,7 @@
     ConsumeAnyToken();
 
     DeclGroupPtrTy Ptr;
-    if (Tok.isOneOf(tok::annot_pragma_openmp, tok::annot_attr_openmp)) {
+    if (Tok.isOneOf(tok::annot_pragma_ft, tok::annot_attr_ft)) {
       Ptr = ParseOpenMPDeclarativeDirectiveWithExtDecl(AS, Attrs, Delayed,
                                                        TagType, Tag);
     } else if (Tok.isNot(tok::r_brace) && !isEofOrEom()) {
@@ -2275,7 +2275,7 @@
   case OMPD_begin_declare_target:
   case OMPD_declare_target: {
     SourceLocation DTLoc = ConsumeAnyToken();
-    bool HasClauses = Tok.isNot(tok::annot_pragma_openmp_end);
+    bool HasClauses = Tok.isNot(tok::annot_pragma_ft_end);
     Sema::DeclareTargetContextInfo DTCI(DKind, DTLoc);
     if (HasClauses)
       ParseOMPDeclareTargetClauses(DTCI);
@@ -2321,7 +2321,6 @@
   case OMPD_taskwait:
   case OMPD_taskgroup:
 // #ifdef DK
-  case OMPD_dkflush:
   case OMPD_vote:
 // #endif
   case OMPD_flush:
@@ -2385,7 +2384,7 @@
   default:
     break;
   }
-  while (Tok.isNot(tok::annot_pragma_openmp_end))
+  while (Tok.isNot(tok::annot_pragma_ft_end))
     ConsumeAnyToken();
   ConsumeAnyToken();
   return nullptr;
@@ -2755,7 +2754,6 @@
   case OMPD_taskwait:
   case OMPD_taskgroup:
 // #ifdef DK
-  case OMPD_dkflush:
   case OMPD_vote:
 // #endif
   case OMPD_flush:
@@ -2847,27 +2845,30 @@
                            ? Tok.getLocation()
                            : ConsumeAnnotationToken(),
                  EndLoc;
-  Token Tok = getCurToken();
-  StringRef S = getPreprocessor().getSpelling(Tok);
+  Token _Tok = getCurToken();
+  StringRef S = getPreprocessor().getSpelling(_Tok);
   DKind = llvm::StringSwitch<OpenMPDirectiveKindExWrapper>(S)
 	.Case("vote", OMPD_vote)
 	.Case("nmr", OMPD_nmr)
         .Default(OMPD_unknown);
-   ConsumeToken();
 
   switch (DKind) {
   case OMPD_vote:
-    HasAssociatedStatement = false;
   case OMPD_nmr:
+    if (DKind == OMPD_vote) {
+      HasAssociatedStatement = false;
+      ImplicitTok = Tok;
+    }
+    else HasAssociatedStatement = true;
     ConsumeToken();
     ImplicitClauseAllowed = true;
     ParseScope OMPDirectiveScope(this, ScopeFlags);
-//    Actions.StartOpenMPDSABlock(DKind, DirName, Actions.getCurScope(), Loc);
-    while (Tok.isNot(tok::annot_pragma_openmp_end)) {
+    Actions.StartOpenMPDSABlock(DKind, DirName, Actions.getCurScope(), Loc);
+    while (Tok.isNot(tok::annot_pragma_ft_end)) {
       // If we are parsing for a directive within a metadirective, the directive
       // ends with a ')'.
       if (ReadDirectiveWithinMetadirective && Tok.is(tok::r_paren)) {
-        while (Tok.isNot(tok::annot_pragma_openmp_end))
+        while (Tok.isNot(tok::annot_pragma_ft_end))
           ConsumeAnyToken();
         break;
       }
@@ -2913,33 +2914,25 @@
 
     StmtResult AssociatedStmt;
     if (HasAssociatedStatement) {	// DK: region
-      // The body is a block scope like in Lambdas and Blocks.
-//      Actions.ActOnOpenMPRegionStart(DKind, getCurScope());
-      // FIXME: We create a bogus CompoundStmt scope to hold the contents of
-      // the captured region. Code elsewhere assumes that any FunctionScopeInfo
-      // should have at least one compound statement scope within it.
-      ParsingOpenMPDirectiveRAII NormalScope(*this, /*Value=*/false);
-      {
-        Sema::CompoundScopeRAII Scope(Actions);
-        AssociatedStmt = ParseStatement();
-
-        if (AssociatedStmt.isUsable() /* && isOpenMPLoopDirective(DKind) &&
-            getLangOpts().OpenMPIRBuilder */)
-          AssociatedStmt = Actions.ActOnOpenMPLoopnest(AssociatedStmt.get());
+      if (DKind == OMPD_nmr) {
+        ParsingOpenMPDirectiveRAII NormalScope(*this, /*Value=*/false);
+        {
+          Sema::CompoundScopeRAII Scope(Actions);
+          AssociatedStmt = ParseStatement();	// DK: here associated statements are parsed
+	}
       }
-      AssociatedStmt = Actions.ActOnOpenMPRegionEnd(AssociatedStmt, Clauses);
+//      AssociatedStmt = Actions.ActOnOpenMPRegionEnd(AssociatedStmt, Clauses);
     } 
-    /*
     Directive = Actions.ActOnOpenMPExecutableDirective(
         DKind, DirName, CancelRegion, Clauses, AssociatedStmt.get(), Loc,
         EndLoc);
 
     // Exit scope.
     Actions.EndOpenMPDSABlock(Directive.get());
-    */
     OMPDirectiveScope.Exit();
     break;
   }
+  return Directive;
 }
 
 /// Parsing of declarative or executable OpenMP directives.
@@ -3240,9 +3233,6 @@
     }
     break;
   }
-// #ifdef DK
-  case OMPD_dkflush:
-// #endif
   case OMPD_vote:
   case OMPD_flush:
   case OMPD_depobj:
@@ -3320,11 +3310,7 @@
     // Special processing for flush and depobj clauses.
     Token ImplicitTok;
     bool ImplicitClauseAllowed = false;
-// ifdef DK
-    if (DKind == OMPD_flush || DKind == OMPD_dkflush || DKind == OMPD_depobj || DKind == OMPD_vote) {
-// else
-//    if (DKind == OMPD_flush || DKind == OMPD_depobj) {
-// endif
+    if (DKind == OMPD_flush || DKind == OMPD_depobj || DKind == OMPD_vote) {
       ImplicitTok = Tok;
       ImplicitClauseAllowed = true;
     }
@@ -3382,9 +3368,6 @@
           CKind = OMPC_flush;
         } 
 // #ifdef DK
-	else if (DKind == OMPD_dkflush) {
-          CKind = OMPC_dkflush;
-        } 
 	else if (DKind == OMPD_vote) {
           CKind = OMPC_vote;
         } 
@@ -3648,16 +3631,16 @@
   bool ErrorFound = false;
   bool WrongDirective = false;
   switch (CKind) {
-    OMPC_vote:	/* LVALUE */
-        Clause = ParseOpenMPDoubleVarListClause(DKind, CKind, WrongDirective);
+    case OMPC_vote:	/* vote now */
+        Clause = ParseFTDoubleVarListClause(DKind, CKind, WrongDirective);
 	break;
-    OMPC_var:	/* LVALUE */
-        Clause = ParseOpenMPDoubleVarListClause(DKind, CKind, WrongDirective);
+    case OMPC_var:	/* LVALUE */
+        Clause = ParseFTDoubleVarListClause(DKind, CKind, WrongDirective);
 	break;
-    OMPC_rvar:	/* RVALUE */
-        Clause = ParseOpenMPDoubleVarListClause(DKind, CKind, WrongDirective);
+    case OMPC_rvar:	/* RVALUE */
+        Clause = ParseFTDoubleVarListClause(DKind, CKind, WrongDirective);
 	break;
-    OMPC_degree:	/* degree of NMR */
+    case OMPC_degree:	/* TODO: degree of NMR */
 	  break;
     default:
 	  ErrorFound = true;
@@ -3866,9 +3849,6 @@
   case OMPC_aligned:
   case OMPC_copyin:
   case OMPC_copyprivate:
-// #ifdef DK
-  case OMPC_dkflush:
-// #endif
   case OMPC_flush:
   case OMPC_depend:
   case OMPC_map:
@@ -5073,10 +5053,9 @@
              Tok.isNot(tok::annot_pragma_openmp_end) &&
              (!MayHaveTail || Tok.isNot(tok::colon)))
       Diag(Tok, diag::err_omp_expected_punc)
-			  // ifdef DK	- without this, dkflush cannot have argument 
+			  // ifdef DK	without this, vote cannot have argument 
           << ((Kind == OMPC_flush) ? getOpenMPDirectiveName(OMPD_flush)
-			: ((Kind == OMPC_dkflush) ? getOpenMPDirectiveName(OMPD_dkflush) 
-			           : ((Kind == OMPC_vote) ? getOpenMPDirectiveName(OMPD_vote) : getOpenMPClauseName(Kind))))
+			           : ((Kind == OMPC_vote) ? getOpenMPDirectiveName(OMPD_vote) : getOpenMPClauseName(Kind)))
 	  		  // else
                           //         : getOpenMPClauseName(Kind))
 			  // endif
@@ -5194,6 +5173,86 @@
 }
 
 // ifdef DK
+OMPClause *Parser::ParseFTDoubleVarListClause(OpenMPDirectiveKind DKind,
+                                            OpenMPClauseKind Kind,
+                                            bool ParseOnly) {
+  SourceLocation Loc = Tok.getLocation();
+  SourceLocation LOpen = ConsumeToken();
+  SmallVector<Expr *, 4> Vars;
+  SmallVector<Expr *, 4> Sizes;
+  OpenMPVarListDataTy Data;
+  OpenMPVarListDataTy DataSizes;
+
+  bool IsComma = true;
+  BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_ft_end);
+  if (T.expectAndConsume(diag::err_expected_lparen_after,
+                         getOpenMPClauseName(Kind).data()))
+    return nullptr;
+
+  while (Tok.isNot(tok::r_paren) /* && Tok.isNot(tok::colon) */ &&
+                     Tok.isNot(tok::annot_pragma_ft_end)) {
+    ParseScope OMPListScope(this, Scope::OpenMPDirectiveScope);
+    ColonProtectionRAIIObject ColonRAII(*this);
+    // Parse variable
+    ExprResult VarExpr =
+        Actions.CorrectDelayedTyposInExpr(ParseAssignmentExpression());
+    if (VarExpr.isUsable()) {
+      Vars.push_back(VarExpr.get());
+    } else {
+      SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_ft_end,
+                StopBeforeMatch);
+    }
+    // Skip ',' if any
+    bool IsColon = Tok.is(tok::colon);
+    IsComma = Tok.is(tok::comma);
+    if (IsColon) {  // size is specified explicitly
+      DataSizes.ColonLoc = ConsumeToken();	// DK: we may not need this. It is overwritten anyway
+      // Parse variable
+      SourceLocation ELoc = Tok.getLocation();
+      ExprResult LHS(
+          ParseCastExpression(AnyCastExpr, false, NotTypeCast));
+      ExprResult Val(ParseRHSOfBinaryExpression(LHS, prec::Conditional));
+      Val = Actions.ActOnFinishFullExpr(Val.get(), ELoc, /*DiscardedValue*/ false);
+      // Parse variable
+      if (Val.isInvalid()) {
+        return nullptr;
+      } else {
+        Sizes.push_back(Val.get());
+        SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_ft_end,
+                  StopBeforeMatch);
+      }
+      IsComma = Tok.is(tok::comma);
+    }  else { // use default value or size of the variable
+        Sizes.push_back(nullptr);
+    }
+    if (IsComma)
+      ConsumeToken();
+  }
+
+  // Parse ')'.
+  Data.RLoc = Tok.getLocation();
+  if (!T.consumeClose())
+    Data.RLoc = T.getCloseLocation();
+
+  if (ParseOnly)
+    return nullptr;
+  OMPVarListLocTy Locs(Loc, LOpen, Data.RLoc);
+  SourceLocation StartLoc = Locs.StartLoc;
+  SourceLocation LParenLoc = Locs.LParenLoc;
+  SourceLocation EndLoc = Locs.EndLoc;
+  return Actions.ActOnOpenMPVarSizeListClause(
+      Kind, Vars, Sizes, StartLoc, LParenLoc, EndLoc);
+ /* 
+  Data.DepModOrTailExpr, Locs, 
+      
+      Data.ColonLoc,
+      Data.ReductionOrMapperIdScopeSpec, Data.ReductionOrMapperId,
+      Data.ExtraModifier, Data.MapTypeModifiers, Data.MapTypeModifiersLoc,
+      Data.IsMapTypeImplicit, Data.ExtraModifierLoc, Data.MotionModifiers,
+      Data.MotionModifiersLoc);
+*/
+}
+
 OMPClause *Parser::ParseOpenMPDoubleVarListClause(OpenMPDirectiveKind DKind,
                                             OpenMPClauseKind Kind,
                                             bool ParseOnly) {
diff -ruN ./clang/lib/Sema/TreeTransform.h ../llvm-project/clang/lib/Sema/TreeTransform.h
--- ./clang/lib/Sema/TreeTransform.h	2023-03-13 16:17:25.172367152 -0400
+++ ../llvm-project/clang/lib/Sema/TreeTransform.h	2023-03-13 14:10:35.855258324 -0400
@@ -8906,7 +8906,7 @@
 StmtResult
 TreeTransform<Derived>::TransformOMPVoteDirective(OMPVoteDirective *D) {
   DeclarationNameInfo DirName;
-  getDerived().getSema().StartOpenMPDSABlock(OMPD_dkflush, DirName, nullptr,
+  getDerived().getSema().StartOpenMPDSABlock(OMPD_vote, DirName, nullptr,
                                              D->getBeginLoc());
   StmtResult Res = getDerived().TransformOMPExecutableDirective(D);
   getDerived().getSema().EndOpenMPDSABlock(Res.get());
